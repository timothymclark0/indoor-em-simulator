from ast import literal_eval
import geopandas as gpd
from itertools import repeat
from matplotlib import pyplot as plt
import numpy as np
import os
import pandas as pd
from shapely.geometry import LineString, Point 
import multiprocessing as mp
from time import perf_counter
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed
from functools import partial
from itertools import product, pairwise
from route_processing import angle_from_north
import astar

def generate_grid_points(bounds, spacing):
    """
    Generate a uniform grid of points within a bounding box.
    Points are indexed with (x,y) coordinates where:
    - x increases from left to right
    - y increases from bottom to top
    
    Parameters:
    bounds (tuple): (minx, miny, maxx, maxy) defining the bounding box
    spacing (float): Distance between adjacent grid points in the same units as bounds
    
    Returns:
    GeoDataFrame: Points with their coordinates and indices
    """
    minx, miny, maxx, maxy = bounds
    
    # Generate coordinate arrays
    x_coords = np.arange(minx, maxx + spacing, spacing)
    y_coords = np.arange(miny, maxy + spacing, spacing)
    
    # Create mesh grid
    xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')
    
    # Create points list with correct indexing
    points = []
    indices = []
    
    # Iterate in reverse y order to match bottom-to-top ordering
    for y_idx, y in enumerate(y_coords[::-1]):
        for x_idx, x in enumerate(x_coords):
            points.append(Point(x, y))
            indices.append((x_idx, y_idx))
    
    # Create DataFrame with point indices
    df = pd.DataFrame({
        'x_idx': [idx[0] for idx in indices],
        'y_idx': [idx[1] for idx in indices],
        'geometry': points
    })
    
    # Convert to GeoDataFrame
    gdf = gpd.GeoDataFrame(df, geometry='geometry',crs = 'EPSG:3857')
    
    # Add coordinate columns for convenience
    gdf['x'] = gdf.geometry.x
    gdf['y'] = gdf.geometry.y
    
    mindex = pd.MultiIndex.from_tuples(indices, names = ['x','y'])
    gdf.index = mindex
    return gdf

def generate_grid_edges(points_gdf, spacing):
    """
    Generate edges between neighboring grid points, including diagonal connections.
    
    Parameters:
    points_gdf (GeoDataFrame): Grid points generated by generate_grid_points
    spacing (float): Distance between adjacent grid points
    
    Returns:
    GeoDataFrame: Edges with their properties (distance, cost, connected nodes)
    """
    node_connections = set()
    
    def connect_neighbors(node):
        nonlocal node_connections
        x,y = node
        neighbors = [coord for coord in product(range(x - 1, x + 2), range(y-1, y+2)) if coord != node]
        ext_neighbors = filter(lambda coord: coord in points_gdf.index, neighbors)
        valid_neighbors = list(filter(lambda coord: not tuple(sorted((coord, node))) in node_connections, ext_neighbors))
        coord_pairs = [tuple(sorted((node, coord))) for coord in valid_neighbors]
        lines = list(map(lambda coord: LineString([points_gdf.loc[node, 'geometry'], points_gdf.loc[coord, 'geometry']]), valid_neighbors))
        edges_dict = [{'points': x, 'geometry': y} for x,y in zip(coord_pairs, lines)]
        return edges_dict
        
    edges = []
    
    for node, row in points_gdf.iterrows():
        neighbor_dict = connect_neighbors(node)
        edges += neighbor_dict
    
    # Create GeoDataFrame from edges
    edges_gdf = gpd.GeoDataFrame(edges, geometry='geometry', crs='EPSG:3857')
    edges_gdf.index = pd.MultiIndex.from_tuples(edges_gdf['points'], names = ['p1', 'p2'])
    edges_gdf['distance'] = edges_gdf['geometry'].length
    edges_gdf['cost'] = edges_gdf['distance']
    return edges_gdf

def prune_network(points,edges,details,spacing=0.6):
    """Prunes the basic network by removing edges that intersect with details. Prunes nodes that have no connections left"""
    difference_geom = gpd.GeoDataFrame({'geometry': [details.union_all().buffer(spacing / 2)] }, crs = details.crs)
    
    points['idx'] = pd.MultiIndex.from_frame(points.loc[:,['x_idx','y_idx']])
    edges['idx'] = pd.MultiIndex.from_frame(edges.loc[:,['p1','p2']])
    pruned_nodes_labels = pd.MultiIndex.from_frame(points.overlay(difference_geom, how='intersection').loc[:,['x_idx','y_idx']]) 
    nodes_idx = points['idx'].isin(pruned_nodes_labels)
    points['idx'].isin(pruned_nodes_labels)
    pruned_nodes_labels_set = set(pruned_nodes_labels)
    pruned_nodes = points.loc[~nodes_idx] 
    
    edges_idx = edges['idx'].map(lambda pair: pair[0] in pruned_nodes_labels_set or pair[1] in pruned_nodes_labels_set)
    pruned_edges = edges.loc[~edges_idx]

    return pruned_nodes, pruned_edges


def apply_wall_distance_penalty(edges, details, max_penalty=1.8, decay_distance=4):
    """
    Adjusts edge costs based on proximity to walls/obstacles using an exponential decay function.
    The penalty decreases exponentially as distance from walls increases.
    
    Parameters:
    edges (GeoDataFrame): Network edges with geometry and cost columns
    details (GeoDataFrame): Wall/obstacle features
    max_penalty (float): Maximum multiplier for edge cost when directly adjacent to walls
    decay_distance (float): Distance (in meters) at which penalty reduces by ~63% (1/e)
    
    Returns:
    GeoDataFrame: Edges with updated costs including wall proximity penalties
    """
    # Create a copy to avoid modifying the original
    edges_with_penalty = edges.copy()
    
    # Convert details to single geometry if multiple features exist
    unioned_details = details.union_all()
    
    # Calculate centroids of all edges
    edge_centroids = edges_with_penalty.geometry.centroid
    
    # Calculate distance from each edge centroid to nearest wall
    distances = edge_centroids.distance(unioned_details)
    
    # Calculate penalty using exponential decay function
    # penalty = max_penalty * e^(-distance/decay_distance)
    penalties = max_penalty * np.exp(-distances/decay_distance)
    
    # Apply penalty to edge costs
    # New cost = original_cost * (1 + penalty)
    edges_with_penalty['wall_distance'] = distances
    edges_with_penalty['distance_penalty'] = penalties
    edges_with_penalty['cost'] = edges_with_penalty['cost'] * (1 + penalties)
    
    return edges_with_penalty

def heuristic(node1, node2, nodes_gdf, spacing=0.6):
    """
    Calculate the Euclidean distance between two nodes as the heuristic.
    
    Parameters:
    node1: ID of the first node
    node2: ID of the second node
    nodes_gdf (GeoDataFrame): Network nodes
    
    Returns:
    float: Estimated distance between nodes
    """
    point1 = nodes_gdf.loc[node1,['x_idx','y_idx']]
    point2 = nodes_gdf.loc[node2,['x_idx','y_idx']]
    deltax = abs(point1['x_idx'] - point2['x_idx']) 
    deltay = abs(point1['y_idx'] - point2['y_idx']) 
    straight_line = abs( deltax - deltay) 
    diagonal_units = max(deltax,deltay) - straight_line 
    h_distance = ((np.sqrt(2) * spacing) * diagonal_units) + (straight_line * spacing)
    return h_distance


def get_neighbors(node_id, nodes_gdf, edges_gdf):
    """
    Get all neighboring nodes and costs for a given node.
    
    Parameters:
    node_id: ID of the node to get neighbors for
    edges_gdf (GeoDataFrame): Network edges
    
    Returns:
    list: Tuples of (neighbor_id, cost) for each neighbor
    """
    # Get edges starting from this node
    x,y = node_id
    neighbors = [coord for coord in product(range(x - 1, x + 2), range(y-1, y+2)) if coord != node_id]
    ext_neighbors = filter(lambda coord: coord in nodes_gdf.index, neighbors)
    valid_neighbors = filter(lambda coord: tuple(sorted((node_id, coord))) in edges_gdf.index, ext_neighbors)
    
    return valid_neighbors

def node_distance(n1, n2, edges_gdf):
    node_id = tuple(sorted((n1, n2)))
    if node_id in edges_gdf.index:
        return edges_gdf.loc[node_id, 'cost']

class RouteSolver(astar.AStar):
    def __init__(self, nodes, edges):
        self.nodes = nodes
        self.edges = edges 
        
        self.edges.loc[:,['p1','p2']] = edges.loc[:,['p1','p2']].map(lambda item: literal_eval(str(item)))
        
        self.nodes.index = pd.MultiIndex.from_frame(
        pd.DataFrame(self.nodes.loc[:,['x','y']]),
        names = ['x','y'])
    
        self.edges.index = pd.MultiIndex.from_frame(
            self.edges.loc[:,['p1','p2']], names=['p1', 'p2']
        )
        
        self.nodes.sort_index(inplace = True)
        self.edges.sort_index(inplace = True)
            
        
    def neighbors(self, node):
        return get_neighbors(node, self.nodes, self.edges)
    
    def distance_between(self, n1, n2):
        node_id = tuple(sorted((n1, n2)))
        if node_id in self.edges.index:
            return self.edges.loc[node_id, 'cost'].iloc[0]
        
    def heuristic_cost_estimate(self, n1, n2):
        return heuristic(n1, n2, self.nodes)
    

def find_path(start_node, end_node, nodes_gdf, edges_gdf):
    """
    Find the shortest path between two nodes using A* algorithm.
    
    Parameters:
    start_node: ID of the starting node
    end_node: ID of the target node
    nodes_gdf (GeoDataFrame): Network nodes
    edges_gdf (GeoDataFrame): Network edges
    
    Returns:
    tuple: (path, total_cost) where path is a list of node IDs and total_cost is the path cost
    """
    
    
    
    from queue import PriorityQueue
    import numpy as np
    astar.find_path()
    # Initialize the frontier with start node
    frontier = PriorityQueue()
    frontier.put((0, start_node))
    
    # Initialize the cost and path dictionaries
    came_from = {start_node: None}
    cost_so_far = {start_node: 0}
    
    while not frontier.empty():
        current_cost, current_node = frontier.get()
        
        # If we reached the goal, reconstruct and return the path
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current)
                current = came_from[current]
            path.reverse()
            return path, cost_so_far[end_node]
        
        # Check all neighbors
        for next_node, edge_cost in get_neighbors(current_node, edges_gdf):
            new_cost = cost_so_far[current_node] + edge_cost
            
            # If we found a better path to this node, update it
            if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                cost_so_far[next_node] = new_cost
                # Priority is f(n) = g(n) + h(n)
                priority = new_cost + heuristic(next_node, end_node, nodes_gdf)
                frontier.put((priority, next_node))
                came_from[next_node] = current_node
    
    # If we get here, no path was found
    return None, None

def get_path_geometry(path, nodes_gdf, edges_gdf):
    """
    Convert a path (list of node IDs) into a LineString geometry.
    
    Parameters:
    path: List of node IDs representing the path
    nodes_gdf (GeoDataFrame): Network nodes
    edges_gdf (GeoDataFrame): Network edges
    
    Returns:
    LineString: geometry of path
    """
    if path is None:
        return None
    vertices = nodes_gdf.loc[path]['geometry']
    #create line and drop extra points
    geometry = LineString(vertices).simplify(0)
    return geometry

def snap_points_to_network(points_gdf, network_nodes_gdf):
    """
    Snap points to nearest network nodes.
    
    Parameters:
    points_gdf (GeoDataFrame): Points to snap
    network_nodes_gdf (GeoDataFrame): Network nodes to snap to
    
    Returns:
    DataFrame: Original point IDs mapped to nearest network node IDs and distances
    """
    snapped_points = []
    
    for idx, point in points_gdf.iterrows():
        # Calculate distances to all nodes
        distances = network_nodes_gdf.geometry.distance(point.geometry)
        # Find closest node
        nearest_node_id = distances.idxmin()
        snap_distance = distances.min()
        
        snapped_points.append({
            'original_id': idx,
            'node_id': nearest_node_id,
            'snap_distance': snap_distance
        })
    
    return pd.DataFrame(snapped_points)

def find_nearest_facilities(incidents_gdf, facilities_gdf, network_nodes_gdf, 
                          network_edges_gdf, n_nearest=1):
    """
    Find paths from each incident to its n nearest facilities.
    
    Parameters:
    incidents_gdf (GeoDataFrame): Origin points
    facilities_gdf (GeoDataFrame): Destination points
    network_nodes_gdf (GeoDataFrame): Network nodes
    network_edges_gdf (GeoDataFrame): Network edges
    n_nearest (int): Number of nearest facilities to find for each incident
    
    Returns:
    GeoDataFrame: Paths from incidents to their nearest facilities
    """
    # Snap incidents and facilities to network
    snapped_incidents = snap_points_to_network(incidents_gdf, network_nodes_gdf)
    snapped_facilities = snap_points_to_network(facilities_gdf, network_nodes_gdf)
    
    # Store all paths
    all_paths = []
    
    # Process each incident
    for _, incident in snapped_incidents.iterrows():
        incident_paths = []
        start_node = incident['node_id']
        
        # Find path to each facility
        for _, facility in snapped_facilities.iterrows():
            end_node = facility['node_id']
            
            # Skip if incident is snapped to same node as facility
            if start_node == end_node:
                path_cost = incident['snap_distance'] + facility['snap_distance']
                path_geom = None
            else:
                # Find path using A*
                path_nodes, path_cost = find_path(start_node, end_node, 
                                                network_nodes_gdf, network_edges_gdf)
                
                if path_nodes:
                    # Get path geometry
                    path_geom = get_path_geometry(path_nodes, network_nodes_gdf, network_edges_gdf)
                    # Add snapping distances to total cost
                    path_cost += incident['snap_distance'] + facility['snap_distance']
                else:
                    path_geom = None
            
            incident_paths.append({
                'incident_id': incident['original_id'],
                'facility_id': facility['original_id'],
                'path_geom': path_geom,
                'total_cost': path_cost if path_cost is not None else float('inf')
            })
        
        # Sort paths by cost and take n nearest
        incident_paths.sort(key=lambda x: x['total_cost'])
        nearest_paths = incident_paths[:n_nearest]
        
        # Add to results
        all_paths.extend(nearest_paths)
    
    # Convert results to GeoDataFrame
    path_records = []
    
    for path_info in all_paths:
        if path_info['path_geom'] is not None:
            # Combine all path edges into a single record
            
            path_records.append({
                'incident_id': path_info['incident_id'],
                'facility_id': path_info['facility_id'],
                'total_cost': path_info['total_cost'],
                'geometry': path_info['path_geom']
            })
    
    # Create GeoDataFrame from results
    paths_gdf = gpd.GeoDataFrame(path_records, geometry='geometry', crs='EPSG:3857')
    
    return paths_gdf

def plot_incident_facility_paths(paths_gdf, incidents_gdf, facilities_gdf, 
                               network_edges_gdf, details_gdf, figsize=(15, 15)):
    """
    Plot all paths between incidents and their nearest facilities.
    
    Parameters:
    paths_gdf (GeoDataFrame): Paths between incidents and facilities
    incidents_gdf (GeoDataFrame): Origin points
    facilities_gdf (GeoDataFrame): Destination points
    network_edges_gdf (GeoDataFrame): Network edges
    details_gdf (GeoDataFrame): Wall/obstacle features
    figsize (tuple): Figure size in inches
    """
    import matplotlib.pyplot as plt
    
    fig, ax = plt.subplots(figsize=figsize)
    
    # Plot network
    network_edges_gdf.plot(ax=ax, color='lightgray', linewidth=1, alpha=0.5)
    
    # Plot walls/obstacles
    details_gdf.plot(ax=ax, color='black', linewidth=1.5)
    
    # Plot paths with different colors for each incident
    colors = plt.cm.rainbow(np.linspace(0, 1, len(incidents_gdf)))
    
    for idx, incident in incidents_gdf.iterrows():
        incident_paths = paths_gdf[paths_gdf['incident_id'] == idx]
        color = colors[idx]
        
        # Plot paths from this incident
        if not incident_paths.empty:
            incident_paths.plot(ax=ax, color=color, linewidth=2, alpha=0.7)
    
    # Plot incidents and facilities
    incidents_gdf.plot(ax=ax, color='green', markersize=100, alpha=0.6, label='Incidents')
    facilities_gdf.plot(ax=ax, color='red', markersize=100, alpha=0.6, label='Facilities')
    
    # Add title and legend
    ax.set_title('Paths from Incidents to Nearest Facilities', fontsize=16)
    ax.legend(fontsize=12)
    
    return fig, ax

def calculate_euclidean_distances(incidents_gdf, facilities_gdf):
    """Calculate euclidean distances between all incidents and facilities.
    Returns a DataFrame with incident_id, facility_id, and distance."""
    distances = []
    for idx1, incident in incidents_gdf.iterrows():
        for idx2, facility in facilities_gdf.iterrows():
            distance = incident.geometry.distance(facility.geometry)
            distances.append({
                'incident_id': idx1,
                'facility_id': idx2,
                'euclidean_distance': distance
            })
    return pd.DataFrame(distances)

def find_path_with_heuristic(start_node, end_node, nodes_gdf, edges_gdf, max_distance=float('inf')):
    """Modified A* pathfinding that uses a maximum distance cutoff."""
    from queue import PriorityQueue
    
    # If the heuristic distance is already greater than max_distance, return None
    h_distance = heuristic(start_node, end_node, nodes_gdf)
    if h_distance > max_distance:
        return None, None

    frontier = PriorityQueue()
    frontier.put((0, start_node))
    
    came_from = {start_node: None}
    cost_so_far = {start_node: 0}
    
    traversed = set()
    while not frontier.empty():
        h_dist, current_node = frontier.get()
        
        if current_node == end_node:
            path = []
            current = current_node
            while current is not None:
                path.append(current)
                current = came_from[current]
            path.reverse()
            return path, cost_so_far[end_node]
        
        for next_node, edge_cost in get_neighbors(current_node, edges_gdf):
            new_cost = cost_so_far[current_node] + edge_cost
            
            # Skip if the new cost plus heuristic is greater than max_distance
            if new_cost + heuristic(next_node, end_node, nodes_gdf) > max_distance:
                continue
                
            if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                cost_so_far[next_node] = new_cost
                priority = new_cost + heuristic(next_node, end_node, nodes_gdf)
                frontier.put((priority, next_node))
                came_from[next_node] = current_node
    
    return None, None

def process_single_incident(incident_data, facilities_gdf, solver: RouteSolver):
    """Process a single incident against all facilities in parallel."""
    incident_id, incident = incident_data
    incident_paths = []
    best_cost = float('inf')
    
    incident_node = snap_points_to_network(
        gpd.GeoDataFrame(geometry=[incident.geometry]), 
        solver.nodes
    ).iloc[0]['node_id'] 
    
    # Calculate euclidean distances to all facilities
    working_facilities = snap_points_to_network(facilities_gdf,solver.nodes)
    working_facilities['h_distance'] = working_facilities['node_id'].map(lambda row: heuristic(incident_node, row,solver.nodes))
    working_facilities.sort_values('h_distance', inplace = True)
    working_facilities.index = working_facilities['original_id'] 
    
    # Process each facility in order of increasing euclidean distance
    for idx, row in working_facilities.iterrows():
        # Skip if euclidean distance is greater than best found path
        if row['h_distance'] > best_cost:
            continue
        
        path = solver.astar(incident_node, row['node_id']) 
        path = list(path)
        edge_indexes = pd.MultiIndex.from_tuples([tuple(sorted(pair)) for pair in pairwise(path)])
        cost = solver.edges.loc[edge_indexes, 'cost'].sum()
        
        if cost < best_cost:
            best_path = path
            best_cost = cost
            best_exit = idx
            
            
    if best_path:
        path_points = solver.nodes.loc[best_path, 'geometry']
        path_geom = LineString(path_points).simplify(0)
        if path_geom:
            incident_paths.append({
                'incident_id': incident_id,
                'facility_id': best_exit,
                'geometry': path_geom,
                'total_cost': best_cost
            })
    # Return the best path found
    if incident_paths:
        return min(incident_paths, key=lambda x: x['total_cost'])
    return None

def generate_routing_network(details: gpd.GeoDataFrame,spacing: float):
    bounds = details.union_all().buffer(1).bounds
    st = perf_counter()
    points = generate_grid_points(bounds, spacing)
    
    #rotate points to match the orientation of the building footprint
    mbr = details.union_all().minimum_rotated_rectangle.exterior
    rotation = angle_from_north(Point(mbr.coords[0]), Point(mbr.coords[1]))
    points['geometry'] = points.rotate(rotation, origin = points.union_all().centroid, use_radians=True) 
    
    edges = generate_grid_edges(points, spacing)
    #prune nodes that are too close to walls
    pruned_nodes, pruned_edges = prune_network(points, edges, details, spacing)
    
    #apply wall distance penalty
    edges_with_penalties = apply_wall_distance_penalty(pruned_edges, details)
    
    #apply center of hallway reward (cut penalty to zero) 
    walls = gpd.GeoDataFrame(geometry = [details.loc[details['USE_TYPE'].isin(['A-WALL-INTERIOR','A-WALL-EXTERIOR'])].union_all()]
        ).explode().simplify(0.01).reset_index(drop=True).segmentize(0.1)

    
    #voronoi polygons of all details vertices will naturally draw a line through the center of openings
    #and carve paths of reasonable distance from walls 
    voronoi = (gpd.GeoDataFrame(geometry=walls.voronoi_polygons())
        .sjoin(gpd.GeoDataFrame(geometry=walls), how='inner')
        .dissolve(by='index_right') #dissolve by which line segment owns the point voronoi'd
        .boundary
        .buffer((spacing / 2)) #buffer just enough to cover parallel network edges
        .union_all()
    )
    voronoi = gpd.GeoDataFrame(geometry = [voronoi], crs = 'EPSG:3857')
    #edges_with_penalties['idx'] = edges_with_penalties.index
    #reward_edges_idx = edges_with_penalties.overlay(voronoi, how='intersection')['idx'].unique()
    #contains_edges = edges_with_penalties.loc[reward_edges_idx].within(voronoi.union_all())
    
    #reset cost to base distance without wall distance penalty
    #possible optimization: calc this first?
    #edges_with_penalties.loc[contains_edges[contains_edges].index, 'cost'] = edges_with_penalties.loc[contains_edges[contains_edges].index, 'distance']
    
    #primary_edges = edges_with_penalties.copy()
    #primary_edges['p1'] = primary_edges['geometry'].apply(lambda x: Point(x.coords[0]))
    #primary_edges['p2'] = primary_edges['geometry'].apply(lambda x: Point(x.coords[-1]))
    #primary_edges['d1'] = primary_edges['geometry'].distance(voronoi)
    #primary_edges['d2'] = primary_edges['geometry'].distance(voronoi)
    #primary_edges_idx = (primary_edges['d1']  < (spacing / 2)) * (primary_edges['d2'] < (spacing / 2))
    #edges_with_penalties.loc[primary_edges_idx, 'cost'] = edges_with_penalties.loc[primary_edges_idx, 'distance']
    
    first_points = edges_with_penalties.apply(lambda row: pruned_nodes.loc[row.name[0], 'geometry'], axis=1) 
    second_points = edges_with_penalties.apply(lambda row: pruned_nodes.loc[row.name[0], 'geometry'], axis=1)
    
    fp_join = gpd.GeoDataFrame(geometry=first_points, crs = 'EPSG:3857').sjoin(voronoi, how='inner')
    sp_join = gpd.GeoDataFrame(geometry = second_points, crs = 'EPSG:3857').sjoin(voronoi, how='inner')

    contains_idx = pd.MultiIndex.from_tuples(
        list(set(fp_join.index).
        intersection(set(sp_join.index))),
        names = ['p1', 'p2'])
    edges_with_penalties.loc[contains_idx, 'cost'] = edges_with_penalties.loc[contains_idx, 'distance']
    
    pruned_nodes.sort_index(inplace = True)
    edges_with_penalties.sort_index(inplace = True)
    print(f'Time taken to generate network: {perf_counter() - st} seconds')
    return pruned_nodes, edges_with_penalties

def solve_routes(network_nodes, network_edges, incidents, facilities, n_processes=None):
    """
    Solve routes from each incident to its nearest facility using parallel processing
    and distance-based heuristics.
    
    Parameters:
    network_nodes (GeoDataFrame): Network nodes
    network_edges (GeoDataFrame): Network edges
    incidents (GeoDataFrame): Incidents to solve routes for
    facilities (GeoDataFrame): Facilities to solve routes to
    n_processes (int): Number of processes to use for parallel processing
    
    Returns:
    GeoDataFrame: Paths from incidents to their nearest facilities
    """
    if n_processes is None:
        n_processes = max(1, mp.cpu_count() - 1)
    n_processes = min(n_processes, mp.cpu_count() -1)
    
    
    solver = RouteSolver(network_nodes, network_edges)
    
    incidents.index = incidents['id']
    facilities.index = facilities['id']
    # Create a partial function with the common arguments
    process_incident_partial = partial(
        process_single_incident,
        facilities_gdf=facilities,
        solver = solver
    )
    
    # Process incidents in parallel
    results = []
    with ProcessPoolExecutor(max_workers=n_processes) as executor:
        futures = [executor.submit(process_incident_partial, incident_data) 
                  for incident_data in incidents.iterrows()]
        for future in as_completed(futures):
            try:
                result = future.result()
                if result is not None:
                    results.append(result)
            except Exception as e:
                print(f"Error processing incident: {e}")
    
    # Create GeoDataFrame from results
    if not results:
        return gpd.GeoDataFrame({'geometry': []})
    
    paths_gdf = gpd.GeoDataFrame(results, geometry='geometry', crs=incidents.crs)
    return paths_gdf

def plot_network_costs(edges_gdf, details_gdf=None, figsize=(15, 15), cmap='viridis', title='Network Edge Costs'):
    """
    Plot network edges with colors based on their cost values.
    
    Parameters:
    edges_gdf (GeoDataFrame): Network edges with 'cost' column
    details_gdf (GeoDataFrame, optional): Wall/obstacle features to overlay
    figsize (tuple): Figure size in inches
    cmap (str): Matplotlib colormap name to use
    title (str): Plot title
    
    Returns:
    tuple: (figure, axis) matplotlib objects
    """
    # Create figure and axis
    fig, ax = plt.subplots(figsize=figsize)
    
    # Normalize costs for color mapping
    norm = plt.Normalize(edges_gdf['cost'].min(), edges_gdf['cost'].max())
    
    # Plot edges with color scale
    edges_gdf.plot(ax=ax, column='cost', cmap=cmap, norm=norm, linewidth=2)
    
    # Add colorbar
    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])
    plt.colorbar(sm, ax=ax, label='Edge Cost')
    
    # Plot details/walls if provided
    if details_gdf is not None:
        details_gdf.plot(ax=ax, color='black', linewidth=1.5, alpha=0.7)
    
    # Add title
    ax.set_title(title, fontsize=16)
    
    # Remove axes
    ax.set_axis_off()
    
    return fig, ax

if __name__ == "__main__":
    # Your example code here
    os.chdir(r'c:\users\tctim\documents\arcgis\projects\em-demo')
    dets = gpd.read_file('details.geojson')
    incidents = gpd.read_file('evacuees.geojson')
    facilities = gpd.read_file('exits.geojson')
    
    network_nodes, network_edges = generate_routing_network(dets, 0.6)
    #network_nodes, network_edges = prune_network(network_nodes, network_edges, dets, 0.6)
    
    #network_edges.to_file('test_network_edges.geojson')
    #network_nodes.to_file('test_network_nodes.geojson')
        
    #paths = solve_routes(network_nodes,network_edges,incidents, facilities)
    #fig1, ax1 = plot_incident_facility_paths(paths,incidents,facilities, network_edges, dets)
    fig2, ax2 = plot_network_costs(network_edges, dets)
    plt.show()
    # ... rest of your example code ...

